syntax = "proto3";

package proto;

// Combined ClientApi
service Api {
    rpc SetAttr(SetAttrRequest) returns (Attr) {}
    rpc GetAttr(Node) returns (Attr)     {}
    rpc Read(ReadRequest) returns (FileChunk) {}
    rpc Write(FileChunk) returns (WriteResponse) {}
    rpc MkDir(DirEnt) returns (DirEnt) {}
    rpc Create(DirEnt) returns (DirEnt) {}
    rpc Remove(DirEnt) returns (WriteResponse) {}
    rpc Lookup(LookupRequest) returns (DirEnt) {}
    rpc ReadDirAll(Node) returns (DirEntries) {}
    rpc Symlink(SymlinkRequest) returns (DirEnt) {}
    rpc Readlink(Node) returns (ReadlinkResponse) {}
    rpc Getxattr(GetxattrRequest) returns (GetxattrResponse) {}
    rpc Setxattr(SetxattrRequest) returns (SetxattrResponse) {}
    rpc Listxattr(ListxattrRequest) returns (ListxattrResponse) {}
    rpc Removexattr(RemovexattrRequest) returns (RemovexattrResponse) {}
    rpc Rename(RenameRequest) returns (RenameResponse) {}
    rpc Statfs(StatfsRequest) returns (StatfsResponse) {}
}

// Node is the file inode
message Node {
    uint64 inode = 1;
}

// Lookup
message LookupRequest {
    string name   = 1;
    uint64 parent = 2; //where to lookup (inode)
}

// Attr. fields are optional by default in proto3, so
// clients don't have to send all fields when performing an
// attr update for example. These might not all be needed
// but i got tired of constantly forgetting fields.
message Attr {
    uint64 inode  = 1;
    int64  atime  = 2;
    int64  mtime  = 3;
    int64  ctime  = 4;
    int64  crtime = 5;
    uint32 mode   = 6;
    int32  valid  = 7;
    uint64 size   = 8;
    uint32 uid    = 9;
    uint32 gid    = 10;
}

message SetAttrRequest {
    bool   setMode  = 1;
    bool   setMtime = 2;
    bool   setSize  = 3;
    bool   setUid   = 4;
    bool   setGid   = 5;
    uint64 inode     = 6;
    int64  mtime     = 7;
    uint32 mode      = 8;
    uint64 size      = 9;
    uint32 uid       = 10;
    uint32 gid       = 11;
}

// ReqadRequest
message ReadRequest {
    uint64 inode   = 1;
    int64  offset  = 2;
    int64  size    = 3;
}

// WriteRequest
message FileChunk {
    uint64 inode   = 1;
    int64  offset  = 2;
    bytes  payload = 3;
}

// WriteResponse place holder. Maybe use an enum so
// we can map to fuse errors ?
message WriteResponse {
    int32 status = 1;
}


// DirEnt is a directory entry
message DirEnt {
    string name   = 1;
    uint64 parent = 2;
    Attr   attr   = 3;
}

// DirEntries just contains a list of directory entries
message DirEntries {
    repeated DirEnt DirEntries  = 1;
    repeated DirEnt FileEntries = 2;
}

// Symlink
message SymlinkRequest {
    string name     = 1;
    uint64 parent   = 2;
    string target   = 3;
}

// Readlink
message ReadlinkResponse {
    string target = 1;
}

// Getxattr
message GetxattrRequest {
    uint64 inode = 1;
    string name = 2;
    uint32  size = 3;
    uint32  position = 4;
}
message GetxattrResponse {
    bytes xattr = 1;
}

// Setxattr
message SetxattrRequest {
    uint64 inode = 1;
    string name = 2;
    bytes xattr = 3;
    uint32 position = 4;
    uint32 flags = 5;
}
message SetxattrResponse {}

// Listxattr
message ListxattrRequest {
    uint64 inode = 1;
    uint32  size = 2;
    uint32  position = 3;
}
message ListxattrResponse {
    bytes xattr = 1;
}

// Removexattr
message RemovexattrRequest {
    uint64 inode = 1;
    string name = 2;
}
message RemovexattrResponse {}

// Rename
message RenameRequest {
    uint64 parent  = 1;
    uint64 newDir  = 2;
    string oldName = 3;
    string newName = 4;
}
message RenameResponse {}

// Statfs
message StatfsRequest {}
message StatfsResponse {
    uint64 blocks  = 1;
    uint64 bfree   = 2;
    uint64 bavail  = 3;
    uint64 files   = 4;
    uint64 ffree   = 5;
    uint32 bsize   = 6;
    uint32 namelen = 7;
    uint32 frsize  = 8;
}
